#summary How property values are created

Under the hood, A Maker uses "donors" to get the values of the properties of the object it is making. A "donor", is an object that gives a value (or values) to its caller.

When we use a `with(property, value)` clause to define the value of a property for a Maker, the second (value) argument can be a donor. That that donor that is called every time the Maker creates a new instance.

== Same Value Donor ==

The simplest donor is the `SameValueDonor<T>`, which always returns the value that was passed to its constructor.  You will probably not use this type directly, but call overloads of the `with(...)` API call that take values as parameters or use the `theSame` API call to control sharing (see MakerClausesAndSharing).

{{{
Maker<Order> anOrder = an(Order, with(customer, theSame(Customer, with(name, "Alice")))));
}}}

== Makers are Donors ==

A Maker is itself a donor that returns a new object instance every time.  For example, the a(Customer) clause below returns a Maker, which is then used as a donor of Customers for the Order.customer property.  The result is that every Order created by `m` refers to a different customer instance.

{{{
Maker<Order> m = an(Order, with(customer, a(Customer)));
}}}


== Custom Donors ==

We can write new types of donor to define property values in different ways.  A donor is just an object that implements the Donor interface:

{{{
public interface Donor<T> {
    T value();
}
}}}

For example, sometimes we need the value of some property to be different for each instance.  We can write a Donor to do that.  For example, the Donor below returns universally unique ID strings.

{{{
class UUIDValue implements Donor<String> {
    @Override
    public String value() {
        return UUID.randomUUID().toString();
    }
}

Maker<NamedThing> aUniquelyNamedThing = a(NamedThing, with(name, new UUIDValue()));
}}}


== Sequences ==

Sometimes we want values to be allocated from a sequence, so we can predict their values or understand where data has come from in test diagnostics, but do not want to explicitly calculate that sequence.  Again, Donors can help us do this.

Make It Easy provides some abstract base classes to help write donors that generate sequences of values.

An `IndexedSequence<T>` calculates each element of the sequence from its integer index, starting at zero.

{{{
class NameSequence extends IndexedSequence<String> {
    @Override
    protected String valueAt(int index) {
        return Integer.toString(index);
    }
}

Maker<NamedThing> aNamedThing = a(NamedThing, with(name, new NameSequence()));

NamedThing thing0 = make(aNamedThing);
NamedThing thing1 = make(aNamedThing);

assertThat(thing0.name, equalTo("0"));
assertThat(thing1.name, equalTo("1"));
}}}


A `ChainedSequence<T>` calculates each element of the sequence from the element that preceded it.

{{{
Maker<NamedThing> aNamedThing = a(NamedThing, with(name, new ChainedSequence<String>() {
    protected String firstValue() { return "A"; }
    protected String valueAfter(String prevValue) { return prevValue + "'"; }
}));

NamedThing thing0 = make(aNamedThing);
NamedThing thing1 = make(aNamedThing);

assertThat(thing0.name, equalTo("A"));
assertThat(thing1.name, equalTo("A'"));
}}}